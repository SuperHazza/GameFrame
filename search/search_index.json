{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>GameFrame has been developed to take the excellent PyGame libraries and make them more accessible and easy to use for beginner to intermediate programmers. GameFrame aims to help with learning the concepts of text based game programming without getting caught up in the implementation details.</p> <p>GameFrame is set up as an event driven framework. Programmers define Rooms and Room Objects, then write functions to handle certain events such as collisions, button clicks and so on. Just define all the items of your game, then let it run. GameFrame handles the Game loop and collision detection, just register your object for an event and write the code that will run when that event occurs.</p> <p>GameFrame was primarily written for education, however it can be used to make a variety of games that can be can be freely shared, altered and improved. It\u2019s free and available for everyone to use, students, hobbyist and accomplished programmers alike.</p>"},{"location":"#how-to-install","title":"How to Install","text":"<p>To install GameFrame, simply clone the repository to your local machine:</p> <pre><code>git clone https://github.com/your-username/GameFrame.git\n</code></pre> <p>After cloning, navigate into the project directory and install the required dependencies (such as PyGame) using pip:</p> <pre><code>cd GameFrame\npip install -r requirements.txt\n</code></pre>"},{"location":"DataBaseController/","title":"DataBaseController Module","text":""},{"location":"DataBaseController/#GameFrame.DataBaseController.DataBaseController","title":"<code>DataBaseController</code>","text":"<p>Controller class for managing SQLite database connections and queries.</p> <p>Attributes:</p> Name Type Description <code>app_db</code> <code>Connection</code> <p>The SQLite database connection object.</p> <code>app_cursor</code> <code>Cursor</code> <p>The cursor object for executing SQL queries.</p> Source code in <code>GameFrame/DataBaseController.py</code> <pre><code>class DataBaseController:\n    \"\"\"\n    Controller class for managing SQLite database connections and queries.\n\n    Attributes:\n        app_db (sqlite3.Connection): The SQLite database connection object.\n        app_cursor (sqlite3.Cursor): The cursor object for executing SQL queries.\n    \"\"\"\n\n    def __init__(self, dbase_file_name: str):\n        \"\"\"\n        Initializes the DataBaseController with the specified database file.\n\n        Args:\n            dbase_file_name (str): The name of the SQLite database file.\n        \"\"\"\n        app_file_path = os.path.join(os.path.dirname(__file__), dbase_file_name)\n        self.app_db = sqlite3.connect(app_file_path)\n        self.app_cursor = self.app_db.cursor()\n\n    def close(self):\n        \"\"\"\n        Closes the database connection.\n        \"\"\"\n        self.app_db.close()\n</code></pre>"},{"location":"DataBaseController/#GameFrame.DataBaseController.DataBaseController.__init__","title":"<code>__init__(dbase_file_name)</code>","text":"<p>Initializes the DataBaseController with the specified database file.</p> <p>Parameters:</p> Name Type Description Default <code>dbase_file_name</code> <code>str</code> <p>The name of the SQLite database file.</p> required Source code in <code>GameFrame/DataBaseController.py</code> <pre><code>def __init__(self, dbase_file_name: str):\n    \"\"\"\n    Initializes the DataBaseController with the specified database file.\n\n    Args:\n        dbase_file_name (str): The name of the SQLite database file.\n    \"\"\"\n    app_file_path = os.path.join(os.path.dirname(__file__), dbase_file_name)\n    self.app_db = sqlite3.connect(app_file_path)\n    self.app_cursor = self.app_db.cursor()\n</code></pre>"},{"location":"DataBaseController/#GameFrame.DataBaseController.DataBaseController.close","title":"<code>close()</code>","text":"<p>Closes the database connection.</p> Source code in <code>GameFrame/DataBaseController.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the database connection.\n    \"\"\"\n    self.app_db.close()\n</code></pre>"},{"location":"EntryTextObject/","title":"EntryTextObject Module","text":""},{"location":"EntryTextObject/#GameFrame.EntryTextObject.EntryTextObject","title":"<code>EntryTextObject</code>","text":"<p>               Bases: <code>TextObject</code></p> <p>A text input object for handling user entry in a game level.</p> <p>Inherits from TextObject and allows for keyboard input, text editing, and focus management. Used for capturing player names or other short text entries.</p> <p>Attributes:</p> Name Type Description <code>max_len</code> <code>int</code> <p>Maximum allowed length of the input text.</p> <code>handle_key_events</code> <code>bool</code> <p>Whether the object should handle key events.</p> <code>accepting_input</code> <code>bool</code> <p>Whether the object is currently accepting input.</p> <code>active</code> <code>bool</code> <p>Whether the object is currently focused and active.</p> Source code in <code>GameFrame/EntryTextObject.py</code> <pre><code>class EntryTextObject(TextObject):\n    \"\"\"\n    A text input object for handling user entry in a game level.\n\n    Inherits from TextObject and allows for keyboard input, text editing,\n    and focus management. Used for capturing player names or other short text entries.\n\n    Attributes:\n        max_len (int): Maximum allowed length of the input text.\n        handle_key_events (bool): Whether the object should handle key events.\n        accepting_input (bool): Whether the object is currently accepting input.\n        active (bool): Whether the object is currently focused and active.\n    \"\"\"\n\n    def __init__(self, room: Level, x: int, y: int, max_len=4):\n        \"\"\"\n        Initializes the EntryTextObject.\n\n        Args:\n            room (Level): The game level or room where the object is placed.\n            x (int): The x-coordinate of the object.\n            y (int): The y-coordinate of the object.\n            max_len (int, optional): Maximum length of input text. Defaults to 4.\n        \"\"\"\n        TextObject.__init__(self, room, x, y, '')\n        self.max_len = max_len\n        self.handle_key_events = True\n        self.accepting_input = True\n        self.active = True\n\n    def accept_input(self):\n        \"\"\"\n        Enables the object to accept input.\n        \"\"\"\n        self.accepting_input = True\n\n    def set_focus(self, in_focus: bool):\n        \"\"\"\n        Sets the focus state of the object.\n\n        Args:\n            in_focus (bool): True if the object should be active, False otherwise.\n        \"\"\"\n        self.active = in_focus\n\n    def key_pressed(self, key):\n        \"\"\"\n        Handles key press events for text entry.\n\n        Args:\n            key: The pygame key state array.\n        \"\"\"\n        if self.accepting_input and self.active:\n\n            key_recognised = False\n            if key[pygame.K_a]:\n                self.text += 'A'\n                key_recognised = True\n            elif key[pygame.K_b]:\n                self.text += 'B'\n                key_recognised = True\n            elif key[pygame.K_c]:\n                self.text += 'C'\n                key_recognised = True\n            elif key[pygame.K_d]:\n                self.text += 'D'\n                key_recognised = True\n            elif key[pygame.K_e]:\n                self.text += 'E'\n                key_recognised = True\n            elif key[pygame.K_f]:\n                self.text += 'F'\n                key_recognised = True\n            elif key[pygame.K_g]:\n                self.text += 'G'\n                key_recognised = True\n            elif key[pygame.K_h]:\n                self.text += 'H'\n                key_recognised = True\n            elif key[pygame.K_i]:\n                self.text += 'I'\n                key_recognised = True\n            elif key[pygame.K_j]:\n                self.text += 'J'\n                key_recognised = True\n            elif key[pygame.K_k]:\n                self.text += 'K'\n                key_recognised = True\n            elif key[pygame.K_l]:\n                self.text += 'L'\n                key_recognised = True\n            elif key[pygame.K_m]:\n                self.text += 'M'\n                key_recognised = True\n            elif key[pygame.K_n]:\n                self.text += 'N'\n                key_recognised = True\n            elif key[pygame.K_o]:\n                self.text += 'O'\n                key_recognised = True\n            elif key[pygame.K_p]:\n                self.text += 'P'\n                key_recognised = True\n            elif key[pygame.K_q]:\n                self.text += 'Q'\n                key_recognised = True\n            elif key[pygame.K_r]:\n                self.text += 'R'\n                key_recognised = True\n            elif key[pygame.K_s]:\n                self.text += 'S'\n                key_recognised = True\n            elif key[pygame.K_t]:\n                self.text += 'T'\n                key_recognised = True\n            elif key[pygame.K_u]:\n                self.text += 'U'\n                key_recognised = True\n            elif key[pygame.K_v]:\n                self.text += 'V'\n                key_recognised = True\n            elif key[pygame.K_w]:\n                self.text += 'W'\n                key_recognised = True\n            elif key[pygame.K_x]:\n                self.text += 'X'\n                key_recognised = True\n            elif key[pygame.K_y]:\n                self.text += 'Y'\n                key_recognised = True\n            elif key[pygame.K_z]:\n                self.text += 'Z'\n                key_recognised = True\n            elif key[pygame.K_SPACE]:\n                self.text += ' '\n                key_recognised = True\n            elif key[pygame.K_1]:\n                self.text += '1'\n                key_recognised = True\n            elif key[pygame.K_2]:\n                self.text += '2'\n                key_recognised = True\n            elif key[pygame.K_3]:\n                self.text += '3'\n                key_recognised = True\n            elif key[pygame.K_4]:\n                self.text += '4'\n                key_recognised = True\n            elif key[pygame.K_5]:\n                self.text += '5'\n                key_recognised = True\n            elif key[pygame.K_6]:\n                self.text += '6'\n                key_recognised = True\n            elif key[pygame.K_7]:\n                self.text += '7'\n                key_recognised = True\n            elif key[pygame.K_8]:\n                self.text += '8'\n                key_recognised = True\n            elif key[pygame.K_9]:\n                self.text += '9'\n                key_recognised = True\n            elif key[pygame.K_0]:\n                self.text += '0'\n                key_recognised = True\n            elif key[pygame.K_BACKSPACE]:\n                if len(self.text) &gt; 0:\n                    self.text = self.text[:-1]\n                    key_recognised = True\n\n            if key_recognised:\n                if len(self.text) &gt; self.max_len:\n                    self.text = self.text[:-1]\n                self.update_text()\n                Globals.player_name = self.text\n                self.accepting_input = False\n                self.set_timer(5, self.accept_input)\n</code></pre>"},{"location":"EntryTextObject/#GameFrame.EntryTextObject.EntryTextObject.__init__","title":"<code>__init__(room, x, y, max_len=4)</code>","text":"<p>Initializes the EntryTextObject.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Level</code> <p>The game level or room where the object is placed.</p> required <code>x</code> <code>int</code> <p>The x-coordinate of the object.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the object.</p> required <code>max_len</code> <code>int</code> <p>Maximum length of input text. Defaults to 4.</p> <code>4</code> Source code in <code>GameFrame/EntryTextObject.py</code> <pre><code>def __init__(self, room: Level, x: int, y: int, max_len=4):\n    \"\"\"\n    Initializes the EntryTextObject.\n\n    Args:\n        room (Level): The game level or room where the object is placed.\n        x (int): The x-coordinate of the object.\n        y (int): The y-coordinate of the object.\n        max_len (int, optional): Maximum length of input text. Defaults to 4.\n    \"\"\"\n    TextObject.__init__(self, room, x, y, '')\n    self.max_len = max_len\n    self.handle_key_events = True\n    self.accepting_input = True\n    self.active = True\n</code></pre>"},{"location":"EntryTextObject/#GameFrame.EntryTextObject.EntryTextObject.accept_input","title":"<code>accept_input()</code>","text":"<p>Enables the object to accept input.</p> Source code in <code>GameFrame/EntryTextObject.py</code> <pre><code>def accept_input(self):\n    \"\"\"\n    Enables the object to accept input.\n    \"\"\"\n    self.accepting_input = True\n</code></pre>"},{"location":"EntryTextObject/#GameFrame.EntryTextObject.EntryTextObject.key_pressed","title":"<code>key_pressed(key)</code>","text":"<p>Handles key press events for text entry.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>The pygame key state array.</p> required Source code in <code>GameFrame/EntryTextObject.py</code> <pre><code>def key_pressed(self, key):\n    \"\"\"\n    Handles key press events for text entry.\n\n    Args:\n        key: The pygame key state array.\n    \"\"\"\n    if self.accepting_input and self.active:\n\n        key_recognised = False\n        if key[pygame.K_a]:\n            self.text += 'A'\n            key_recognised = True\n        elif key[pygame.K_b]:\n            self.text += 'B'\n            key_recognised = True\n        elif key[pygame.K_c]:\n            self.text += 'C'\n            key_recognised = True\n        elif key[pygame.K_d]:\n            self.text += 'D'\n            key_recognised = True\n        elif key[pygame.K_e]:\n            self.text += 'E'\n            key_recognised = True\n        elif key[pygame.K_f]:\n            self.text += 'F'\n            key_recognised = True\n        elif key[pygame.K_g]:\n            self.text += 'G'\n            key_recognised = True\n        elif key[pygame.K_h]:\n            self.text += 'H'\n            key_recognised = True\n        elif key[pygame.K_i]:\n            self.text += 'I'\n            key_recognised = True\n        elif key[pygame.K_j]:\n            self.text += 'J'\n            key_recognised = True\n        elif key[pygame.K_k]:\n            self.text += 'K'\n            key_recognised = True\n        elif key[pygame.K_l]:\n            self.text += 'L'\n            key_recognised = True\n        elif key[pygame.K_m]:\n            self.text += 'M'\n            key_recognised = True\n        elif key[pygame.K_n]:\n            self.text += 'N'\n            key_recognised = True\n        elif key[pygame.K_o]:\n            self.text += 'O'\n            key_recognised = True\n        elif key[pygame.K_p]:\n            self.text += 'P'\n            key_recognised = True\n        elif key[pygame.K_q]:\n            self.text += 'Q'\n            key_recognised = True\n        elif key[pygame.K_r]:\n            self.text += 'R'\n            key_recognised = True\n        elif key[pygame.K_s]:\n            self.text += 'S'\n            key_recognised = True\n        elif key[pygame.K_t]:\n            self.text += 'T'\n            key_recognised = True\n        elif key[pygame.K_u]:\n            self.text += 'U'\n            key_recognised = True\n        elif key[pygame.K_v]:\n            self.text += 'V'\n            key_recognised = True\n        elif key[pygame.K_w]:\n            self.text += 'W'\n            key_recognised = True\n        elif key[pygame.K_x]:\n            self.text += 'X'\n            key_recognised = True\n        elif key[pygame.K_y]:\n            self.text += 'Y'\n            key_recognised = True\n        elif key[pygame.K_z]:\n            self.text += 'Z'\n            key_recognised = True\n        elif key[pygame.K_SPACE]:\n            self.text += ' '\n            key_recognised = True\n        elif key[pygame.K_1]:\n            self.text += '1'\n            key_recognised = True\n        elif key[pygame.K_2]:\n            self.text += '2'\n            key_recognised = True\n        elif key[pygame.K_3]:\n            self.text += '3'\n            key_recognised = True\n        elif key[pygame.K_4]:\n            self.text += '4'\n            key_recognised = True\n        elif key[pygame.K_5]:\n            self.text += '5'\n            key_recognised = True\n        elif key[pygame.K_6]:\n            self.text += '6'\n            key_recognised = True\n        elif key[pygame.K_7]:\n            self.text += '7'\n            key_recognised = True\n        elif key[pygame.K_8]:\n            self.text += '8'\n            key_recognised = True\n        elif key[pygame.K_9]:\n            self.text += '9'\n            key_recognised = True\n        elif key[pygame.K_0]:\n            self.text += '0'\n            key_recognised = True\n        elif key[pygame.K_BACKSPACE]:\n            if len(self.text) &gt; 0:\n                self.text = self.text[:-1]\n                key_recognised = True\n\n        if key_recognised:\n            if len(self.text) &gt; self.max_len:\n                self.text = self.text[:-1]\n            self.update_text()\n            Globals.player_name = self.text\n            self.accepting_input = False\n            self.set_timer(5, self.accept_input)\n</code></pre>"},{"location":"EntryTextObject/#GameFrame.EntryTextObject.EntryTextObject.set_focus","title":"<code>set_focus(in_focus)</code>","text":"<p>Sets the focus state of the object.</p> <p>Parameters:</p> Name Type Description Default <code>in_focus</code> <code>bool</code> <p>True if the object should be active, False otherwise.</p> required Source code in <code>GameFrame/EntryTextObject.py</code> <pre><code>def set_focus(self, in_focus: bool):\n    \"\"\"\n    Sets the focus state of the object.\n\n    Args:\n        in_focus (bool): True if the object should be active, False otherwise.\n    \"\"\"\n    self.active = in_focus\n</code></pre>"},{"location":"Globals/","title":"Globals Module","text":""},{"location":"Globals/#GameFrame.Globals.Globals","title":"<code>Globals</code>","text":"<p>A class to store global variables and configuration constants for the game.</p> <p>Attributes:</p> Name Type Description <code>running</code> <code>bool</code> <p>Indicates if the game loop is running.</p> <code>FRAMES_PER_SECOND</code> <code>int</code> <p>The target frames per second for the game.</p> <code>SCREEN_WIDTH</code> <code>int</code> <p>The width of the game window.</p> <code>SCREEN_HEIGHT</code> <code>int</code> <p>The height of the game window.</p> <code>SCORE</code> <code>int</code> <p>The player's current score.</p> <code>LIVES</code> <code>int</code> <p>The starting number of lives for the player.</p> <code>window_name</code> <code>str</code> <p>The display name of the game window.</p> <code>levels</code> <code>list</code> <p>The ordered list of level names.</p> <code>start_level</code> <code>int</code> <p>The index of the starting level.</p> <code>end_game_level</code> <code>int</code> <p>The index of the level to jump to when the game ends.</p> <code>next_level</code> <code>int</code> <p>The index of the next level to load.</p> <code>exiting</code> <code>bool</code> <p>Indicates if the game is exiting.</p> <code>total_count</code> <code>int</code> <p>User-defined global variable for total count.</p> <code>destroyed_count</code> <code>int</code> <p>User-defined global variable for destroyed count.</p> Source code in <code>GameFrame/Globals.py</code> <pre><code>class Globals:\n    \"\"\"\n    A class to store global variables and configuration constants for the game.\n\n    Attributes:\n        running (bool): Indicates if the game loop is running.\n        FRAMES_PER_SECOND (int): The target frames per second for the game.\n        SCREEN_WIDTH (int): The width of the game window.\n        SCREEN_HEIGHT (int): The height of the game window.\n        SCORE (int): The player's current score.\n        LIVES (int): The starting number of lives for the player.\n        window_name (str): The display name of the game window.\n        levels (list): The ordered list of level names.\n        start_level (int): The index of the starting level.\n        end_game_level (int): The index of the level to jump to when the game ends.\n        next_level (int): The index of the next level to load.\n        exiting (bool): Indicates if the game is exiting.\n        total_count (int): User-defined global variable for total count.\n        destroyed_count (int): User-defined global variable for destroyed count.\n    \"\"\"\n\n    running = True\n    FRAMES_PER_SECOND = 30\n\n    SCREEN_WIDTH = 800\n    SCREEN_HEIGHT = 600\n\n    SCORE = 0\n\n    # - Set the starting number of lives - #\n    LIVES = 3\n\n    # - Set the Window display name - #\n    window_name = 'GF Game'\n\n    # - Set the order of the rooms - #\n    levels = [\"WelcomeScreen\", \"Maze\", \"ScrollingShooter\", \"BreakOut\"]\n\n    # - Set the starting level - #\n    start_level = 0\n\n    # - Set this number to the level you want to jump to when the game ends - #\n    end_game_level = 4\n\n    # - This variable keeps track of the room that will follow the current room - #\n    # - Change this value to move through rooms in a non-sequential manner - #\n    next_level = 0\n\n    # - Change variable to True to exit the program - #\n    exiting = False\n\n# ############################################################# #\n# ###### User Defined Global Variables below this line ######## #\n# ############################################################# #\n\n    total_count = 0\n    destroyed_count = 0\n</code></pre>"},{"location":"Level/","title":"Level Module","text":""},{"location":"Level/#GameFrame.Level.Level","title":"<code>Level</code>","text":"<p>Represents a game level, managing all objects, events, input, and rendering for that level.</p> <p>Handles the game loop, background, user input (keyboard, mouse, joystick), object management, collision detection, and timed events.</p> <p>Attributes:</p> Name Type Description <code>screen</code> <code>Surface</code> <p>The pygame surface to render the level on.</p> <code>objects</code> <code>list</code> <p>List of all RoomObject instances in the level.</p> <code>keyboard_objects</code> <code>list</code> <p>Objects that handle keyboard events.</p> <code>mouse_objects</code> <code>list</code> <p>Objects that handle mouse events.</p> <code>_clock</code> <code>Clock</code> <p>Clock for managing frame rate.</p> <code>running</code> <code>bool</code> <p>Indicates if the level is currently running.</p> <code>quitting</code> <code>bool</code> <p>Indicates if the level is quitting.</p> <code>background_color</code> <code>tuple</code> <p>RGB color for the background.</p> <code>background_set</code> <code>bool</code> <p>Whether a background image is set.</p> <code>background_image</code> <p>The background image surface or identifier.</p> <code>background_y</code> <code>int</code> <p>Y position for background scrolling.</p> <code>background_scroll_speed</code> <code>int</code> <p>Speed of background scrolling.</p> <code>background_scrolling</code> <code>bool</code> <p>Whether background scrolling is enabled.</p> <code>user_events</code> <code>list</code> <p>List of timed user events.</p> <code>joysticks</code> <code>Joystick</code> <p>List of connected joystick devices.</p> <code>p1_btns</code> <code>list</code> <p>State of player 1's joystick buttons/axes.</p> <code>p2_btns</code> <code>list</code> <p>State of player 2's joystick buttons/axes.</p> <code>has_buttons_1</code> <code>bool</code> <p>Whether player 1's joystick has buttons.</p> <code>has_buttons_2</code> <code>bool</code> <p>Whether player 2's joystick has buttons.</p> <code>has_hat_1</code> <code>bool</code> <p>Whether player 1's joystick has axes.</p> <code>has_hat_2</code> <code>bool</code> <p>Whether player 2's joystick has axes.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>class Level:\n    \"\"\"\n    Represents a game level, managing all objects, events, input, and rendering for that level.\n\n    Handles the game loop, background, user input (keyboard, mouse, joystick), object management,\n    collision detection, and timed events.\n\n    Attributes:\n        screen (Surface): The pygame surface to render the level on.\n        objects (list): List of all RoomObject instances in the level.\n        keyboard_objects (list): Objects that handle keyboard events.\n        mouse_objects (list): Objects that handle mouse events.\n        _clock (pygame.time.Clock): Clock for managing frame rate.\n        running (bool): Indicates if the level is currently running.\n        quitting (bool): Indicates if the level is quitting.\n        background_color (tuple): RGB color for the background.\n        background_set (bool): Whether a background image is set.\n        background_image: The background image surface or identifier.\n        background_y (int): Y position for background scrolling.\n        background_scroll_speed (int): Speed of background scrolling.\n        background_scrolling (bool): Whether background scrolling is enabled.\n        user_events (list): List of timed user events.\n        joysticks (Joystick): List of connected joystick devices.\n        p1_btns (list): State of player 1's joystick buttons/axes.\n        p2_btns (list): State of player 2's joystick buttons/axes.\n        has_buttons_1 (bool): Whether player 1's joystick has buttons.\n        has_buttons_2 (bool): Whether player 2's joystick has buttons.\n        has_hat_1 (bool): Whether player 1's joystick has axes.\n        has_hat_2 (bool): Whether player 2's joystick has axes.\n    \"\"\"\n\n    def __init__(self, screen: Surface, joysticks: Joystick):\n        \"\"\"\n        Initializes the Level with the given screen and joysticks.\n\n        Args:\n            screen (Surface): The pygame surface to render the level on.\n            joysticks (Joystick): List of connected joystick devices.\n        \"\"\"\n        self.screen = screen\n        self.objects = []\n        self.keyboard_objects = []\n        self.mouse_objects = []\n        self._clock = pygame.time.Clock()\n        self.running = False\n        self.quitting = False\n        self.background_color = (0, 0, 0)\n        self.background_set = False\n        self.background_image = 0\n        self.background_y = 0\n        self.background_scroll_speed = 0\n        self.background_scrolling = False\n        self.user_events = []\n        self.joysticks = joysticks\n        self.p1_btns = []\n        self.p2_btns = []\n        self.has_buttons_1 = False\n        self.has_buttons_2 = False\n        self.has_hat_1 = False\n        self.has_hat_2 = False\n        if len(self.joysticks) &gt; 0:\n            buttons = self.joysticks[0].get_numbuttons()\n            if buttons &gt; 0:\n                self.has_buttons_1 = True\n            for i in range(buttons):\n                self.p1_btns.append(self.joysticks[0].get_button(i))\n            axes = self.joysticks[0].get_numaxes()\n            if axes &gt; 0:\n                self.has_hat_1 = True\n            for i in range(axes):\n                self.p1_btns.append(self.joysticks[0].get_axis(i))\n            if len(self.joysticks) &gt; 1:\n                buttons = self.joysticks[1].get_numbuttons()\n                if buttons &gt; 0:\n                    self.has_buttons_2 = True\n                for i in range(buttons):\n                    self.p2_btns.append(self.joysticks[1].get_button(i))\n                axes = self.joysticks[1].get_numaxes()\n                if axes &gt; 0:\n                    self.has_hat_2 = True\n                for i in range(axes):\n                    self.p1_btns.append(self.joysticks[1].get_axis(i))\n\n    def run(self) -&gt; bool:\n        \"\"\"\n        Runs the main game loop for the level.\n\n        Returns:\n            bool: True if the level is quitting, False otherwise.\n        \"\"\"\n        self.running = True\n        for obj in self.objects:\n            self.init_collision_list(obj)\n\n        while self.running:\n            self._clock.tick(Globals.FRAMES_PER_SECOND)\n\n            for obj in self.objects:\n                obj.prev_x = obj.x\n                obj.prev_y = obj.y\n\n            # - Process user events - #\n            self.process_user_events()\n\n            # Call Pre step on all objects\n            for item in self.objects:\n                item.prestep()\n\n            events = pygame.event.get()\n            for event in events:\n                if event.type == pygame.QUIT:\n                    self.running = False\n                    self.quitting = True\n                    Globals.exiting = True\n                    pass\n                # - Check for mouse click and pass to objects registered for mouse events - #\n                if event.type == pygame.MOUSEBUTTONUP:\n                    mouse_pos = pygame.mouse.get_pos()\n                    for obj in self.mouse_objects:\n                        if obj.rect.collidepoint(mouse_pos):\n                            obj.clicked(event.button)\n\n            # -  Check for joystick events and pass  - #\n            # - to objects registered for key events - #\n            signals = False\n            if self.has_buttons_1:\n                for i in range(self.joysticks[0].get_numbuttons()):\n                    self.p1_btns[i] = self.joysticks[0].get_button(i)\n                    if self.p1_btns[i] == 1:\n                        signals = True\n            if self.has_hat_1:\n                for i in range(self.joysticks[0].get_numaxes()):\n                    self.p1_btns[-(i+1)] = self.joysticks[0].get_axis(i)\n                    if self.p1_btns[-(i+1)] &gt; 0 or self.p1_btns[-(i+1)] &lt; 0:\n                        signals = True\n            if self.has_buttons_2:\n                for i in range(self.joysticks[1].get_numbuttons()):\n                    self.p2_btns[i] = self.joysticks[1].get_button(i)\n                    if self.p2_btns[i] == 1:\n                        signals = True\n            if self.has_hat_2:\n                for i in range(self.joysticks[1].get_numaxes()):\n                    self.p1_btns[-i] = self.joysticks[1].get_axis(i)\n                    if self.p2_btns[-i] &gt; 0 or self.p2_btns[-i] &lt; 0:\n                        signals = True\n\n            if signals:\n                for obj in self.keyboard_objects:\n                    obj.joy_pad_signal(self.p1_btns, self.p2_btns)\n\n            # - Check for a keyboard event and pass - #\n            # - to objects registered for key events - #\n            keys = pygame.key.get_pressed()\n            if len(keys):\n                for obj in self.keyboard_objects:\n                    obj.key_pressed(keys)\n\n            # - Check for a mouse event and pass - #\n            # - to objects registered for mouse events - #\n            (mouse_x, mouse_y) = pygame.mouse.get_pos()\n            (button_left, button_middle, button_right) = pygame.mouse.get_pressed()\n            for obj in self.mouse_objects:\n                    obj.mouse_event(mouse_x, mouse_y, button_left, button_middle, button_right)\n\n            # - Handle all other events - #\n            self.catch_events(events)\n\n            # - Clear the screen - #\n            self.screen.fill(self.background_color)\n            # - Add Background if set - #\n            if self.background_set:\n                # - Scrolling if set - #\n                if self.background_scrolling:\n                    self.background_y += self.background_scroll_speed\n                    if self.background_y &gt;= Globals.SCREEN_HEIGHT:\n                        self.background_y = 0\n                    self.screen.blit(self.background_image, (0, self.background_y))\n                    self.screen.blit(self.background_image, (0, self.background_y - Globals.SCREEN_HEIGHT))\n                else:\n                    self.screen.blit(self.background_image, (0, 0))\n            # Call Update on all objects\n            for item in self.objects:\n                item.update()\n                item.step()\n\n            # Check collisions\n            for item in self.objects:\n                item.check_collisions()\n\n            for item in self.objects:\n                self.screen.blit(item.image, (item.x, item.y))\n\n            pygame.display.update()\n\n        return self.quitting\n\n    def set_background_image(self, image_file: str):\n        \"\"\"\n        Sets the background image for the level.\n\n        Args:\n            image_file (str): Filename of the background image.\n        \"\"\"\n        self.background_set = True\n        self.background_image = pygame.image.load(os.path.join('Images', image_file)).convert_alpha()\n\n    def set_background_scroll(self, speed: int):\n        \"\"\"\n        Enables background scrolling at the specified speed.\n\n        Args:\n            speed (int): The scroll speed in pixels per frame.\n        \"\"\"\n        self.background_scrolling = True\n        self.background_scroll_speed = speed\n\n    def add_room_object(self, room_object: RoomObject):\n        \"\"\"\n        Adds a RoomObject to the level and registers it for events as needed.\n\n        Args:\n            room_object (RoomObject): The object to add.\n        \"\"\"\n        # - Add to room objects list - #\n        if len(self.objects) == 0:\n            self.objects.append(room_object)\n        else:\n            for index, item in enumerate(self.objects):\n                if item.depth &gt;= room_object.depth:\n                    self.objects.insert(index, room_object)\n                    break\n                elif index == len(self.objects) - 1:\n                    self.objects.append(room_object)\n                    break\n\n        # - Add objects that handle key events to array - #\n        if room_object.handle_key_events:\n            self.keyboard_objects.append(room_object)\n\n        # - Add objects that handle mouse events to array - #\n        if room_object.handle_mouse_events:\n            self.mouse_objects.append(room_object)\n\n        if self.running:\n            self.dynamic_init_collision_list(room_object)\n\n    def load_sound(self, sound_file: str) -&gt; Sound:\n        \"\"\"\n        Loads a sound file from the Sounds directory.\n\n        Args:\n            sound_file (str): Filename of the sound to load.\n\n        Returns:\n            Sound: The loaded pygame Sound object.\n        \"\"\"\n        fq_filename = os.path.join('Sounds', sound_file)\n        return pygame.mixer.Sound(fq_filename)\n\n    def stop_sound(self):\n        \"\"\"\n        Stops all currently playing sounds.\n        \"\"\"\n        pygame.mixer.stop()\n\n    def load_image(self, file_name: str) -&gt; str:\n        \"\"\"\n        Returns the full path to an image file in the Images directory.\n\n        Args:\n            file_name (str): Filename of the image.\n\n        Returns:\n            str: Full path to the image file.\n        \"\"\"\n        return os.path.join('Images', file_name)\n\n    def init_collision_list(self, room_object: RoomObject):\n        \"\"\"\n        Initializes the collision list for a given object.\n\n        Args:\n            room_object (RoomObject): The object to initialize collisions for.\n        \"\"\"\n        # - Initialise collision list for object - #\n        for obj_name in room_object.collision_object_types:\n            for obj_instance in self.objects:\n                if type(obj_instance).__name__ == obj_name and obj_instance is not room_object:\n                    room_object.collision_objects.append(obj_instance)\n\n    def dynamic_init_collision_list(self, room_object: RoomObject):\n        \"\"\"\n        Dynamically updates collision lists when a new object is added.\n\n        Args:\n            room_object (RoomObject): The new object to add to collision lists.\n        \"\"\"\n        self.init_collision_list(room_object)\n        obj_type = type(room_object).__name__\n        for obj in self.objects:\n            if obj is not room_object:\n                if obj_type in obj.collision_object_types:\n                    obj.collision_objects.append(room_object)\n\n    def catch_events(self, events):\n        \"\"\"\n        Handles additional pygame events not processed elsewhere.\n\n        Args:\n            events: List of pygame events.\n        \"\"\"\n        pass\n\n    def delete_object(self, obj: RoomObject):\n        \"\"\"\n        Removes an object from the level and all event/collision lists.\n\n        Args:\n            obj (RoomObject): The object to remove.\n        \"\"\"\n        for index, list_obj in self.enumerate_backwards(self.objects):\n            if list_obj is obj:\n                self.objects.pop(index)\n            else:\n                list_obj.remove_object(obj)\n        for index, list_obj in self.enumerate_backwards(self.keyboard_objects):\n            if list_obj is obj:\n                self.keyboard_objects.pop(index)\n        for index, list_obj in self.enumerate_backwards(self.mouse_objects):\n            if list_obj is obj:\n                self.mouse_objects.pop(index)\n        # Remove any timed function calls for the deleted object\n        for index, event_method in self.enumerate_backwards(self.user_events):\n            obj_inst = event_method[1].__self__\n            if obj_inst is obj:\n                self.user_events.pop(index)\n\n    def set_timer(self, ticks: int, function_call: Callable):\n        \"\"\"\n        Sets a timed event to call a function after a number of ticks.\n\n        Args:\n            ticks (int): Number of frames to wait before calling the function.\n            function_call (Callable): The function to call.\n        \"\"\"\n        self.user_events.append([ticks, function_call])\n\n    def process_user_events(self):\n        \"\"\"\n        Processes and triggers any timed user events.\n        \"\"\"\n        for index, user_event in self.enumerate_backwards(self.user_events):\n            user_event[0] -= 1\n            if user_event[0] &lt;= 0:\n                event = user_event[1]\n                self.user_events.pop(index)\n                event()\n\n    def count_object(self, object_name):\n        \"\"\"\n        Counts the number of objects of a given type in the level.\n\n        Args:\n            object_name (str): The class name of the object to count.\n\n        Returns:\n            int: The number of objects of the specified type.\n        \"\"\"\n        total = 0\n        for item in self.objects:\n            item_type = type(item).__name__\n            if object_name == item_type:\n                total += 1            \n        return total\n\n    # Iterate backwards over a list, using an index and item iterator\n    def enumerate_backwards(self, object_list: List):\n        \"\"\"\n        Iterates backwards over a list, yielding index and item.\n\n        Args:\n            object_list (List): The list to iterate over.\n\n        Yields:\n            tuple: (index, item) for each element in reverse order.\n        \"\"\"\n        index = len(object_list)\n        for item in reversed(object_list):\n            index -= 1\n            yield index, item\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.__init__","title":"<code>__init__(screen, joysticks)</code>","text":"<p>Initializes the Level with the given screen and joysticks.</p> <p>Parameters:</p> Name Type Description Default <code>screen</code> <code>Surface</code> <p>The pygame surface to render the level on.</p> required <code>joysticks</code> <code>Joystick</code> <p>List of connected joystick devices.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def __init__(self, screen: Surface, joysticks: Joystick):\n    \"\"\"\n    Initializes the Level with the given screen and joysticks.\n\n    Args:\n        screen (Surface): The pygame surface to render the level on.\n        joysticks (Joystick): List of connected joystick devices.\n    \"\"\"\n    self.screen = screen\n    self.objects = []\n    self.keyboard_objects = []\n    self.mouse_objects = []\n    self._clock = pygame.time.Clock()\n    self.running = False\n    self.quitting = False\n    self.background_color = (0, 0, 0)\n    self.background_set = False\n    self.background_image = 0\n    self.background_y = 0\n    self.background_scroll_speed = 0\n    self.background_scrolling = False\n    self.user_events = []\n    self.joysticks = joysticks\n    self.p1_btns = []\n    self.p2_btns = []\n    self.has_buttons_1 = False\n    self.has_buttons_2 = False\n    self.has_hat_1 = False\n    self.has_hat_2 = False\n    if len(self.joysticks) &gt; 0:\n        buttons = self.joysticks[0].get_numbuttons()\n        if buttons &gt; 0:\n            self.has_buttons_1 = True\n        for i in range(buttons):\n            self.p1_btns.append(self.joysticks[0].get_button(i))\n        axes = self.joysticks[0].get_numaxes()\n        if axes &gt; 0:\n            self.has_hat_1 = True\n        for i in range(axes):\n            self.p1_btns.append(self.joysticks[0].get_axis(i))\n        if len(self.joysticks) &gt; 1:\n            buttons = self.joysticks[1].get_numbuttons()\n            if buttons &gt; 0:\n                self.has_buttons_2 = True\n            for i in range(buttons):\n                self.p2_btns.append(self.joysticks[1].get_button(i))\n            axes = self.joysticks[1].get_numaxes()\n            if axes &gt; 0:\n                self.has_hat_2 = True\n            for i in range(axes):\n                self.p1_btns.append(self.joysticks[1].get_axis(i))\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.add_room_object","title":"<code>add_room_object(room_object)</code>","text":"<p>Adds a RoomObject to the level and registers it for events as needed.</p> <p>Parameters:</p> Name Type Description Default <code>room_object</code> <code>RoomObject</code> <p>The object to add.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def add_room_object(self, room_object: RoomObject):\n    \"\"\"\n    Adds a RoomObject to the level and registers it for events as needed.\n\n    Args:\n        room_object (RoomObject): The object to add.\n    \"\"\"\n    # - Add to room objects list - #\n    if len(self.objects) == 0:\n        self.objects.append(room_object)\n    else:\n        for index, item in enumerate(self.objects):\n            if item.depth &gt;= room_object.depth:\n                self.objects.insert(index, room_object)\n                break\n            elif index == len(self.objects) - 1:\n                self.objects.append(room_object)\n                break\n\n    # - Add objects that handle key events to array - #\n    if room_object.handle_key_events:\n        self.keyboard_objects.append(room_object)\n\n    # - Add objects that handle mouse events to array - #\n    if room_object.handle_mouse_events:\n        self.mouse_objects.append(room_object)\n\n    if self.running:\n        self.dynamic_init_collision_list(room_object)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.catch_events","title":"<code>catch_events(events)</code>","text":"<p>Handles additional pygame events not processed elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <p>List of pygame events.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def catch_events(self, events):\n    \"\"\"\n    Handles additional pygame events not processed elsewhere.\n\n    Args:\n        events: List of pygame events.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.count_object","title":"<code>count_object(object_name)</code>","text":"<p>Counts the number of objects of a given type in the level.</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>The class name of the object to count.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of objects of the specified type.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def count_object(self, object_name):\n    \"\"\"\n    Counts the number of objects of a given type in the level.\n\n    Args:\n        object_name (str): The class name of the object to count.\n\n    Returns:\n        int: The number of objects of the specified type.\n    \"\"\"\n    total = 0\n    for item in self.objects:\n        item_type = type(item).__name__\n        if object_name == item_type:\n            total += 1            \n    return total\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.delete_object","title":"<code>delete_object(obj)</code>","text":"<p>Removes an object from the level and all event/collision lists.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>RoomObject</code> <p>The object to remove.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def delete_object(self, obj: RoomObject):\n    \"\"\"\n    Removes an object from the level and all event/collision lists.\n\n    Args:\n        obj (RoomObject): The object to remove.\n    \"\"\"\n    for index, list_obj in self.enumerate_backwards(self.objects):\n        if list_obj is obj:\n            self.objects.pop(index)\n        else:\n            list_obj.remove_object(obj)\n    for index, list_obj in self.enumerate_backwards(self.keyboard_objects):\n        if list_obj is obj:\n            self.keyboard_objects.pop(index)\n    for index, list_obj in self.enumerate_backwards(self.mouse_objects):\n        if list_obj is obj:\n            self.mouse_objects.pop(index)\n    # Remove any timed function calls for the deleted object\n    for index, event_method in self.enumerate_backwards(self.user_events):\n        obj_inst = event_method[1].__self__\n        if obj_inst is obj:\n            self.user_events.pop(index)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.dynamic_init_collision_list","title":"<code>dynamic_init_collision_list(room_object)</code>","text":"<p>Dynamically updates collision lists when a new object is added.</p> <p>Parameters:</p> Name Type Description Default <code>room_object</code> <code>RoomObject</code> <p>The new object to add to collision lists.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def dynamic_init_collision_list(self, room_object: RoomObject):\n    \"\"\"\n    Dynamically updates collision lists when a new object is added.\n\n    Args:\n        room_object (RoomObject): The new object to add to collision lists.\n    \"\"\"\n    self.init_collision_list(room_object)\n    obj_type = type(room_object).__name__\n    for obj in self.objects:\n        if obj is not room_object:\n            if obj_type in obj.collision_object_types:\n                obj.collision_objects.append(room_object)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.enumerate_backwards","title":"<code>enumerate_backwards(object_list)</code>","text":"<p>Iterates backwards over a list, yielding index and item.</p> <p>Parameters:</p> Name Type Description Default <code>object_list</code> <code>List</code> <p>The list to iterate over.</p> required <p>Yields:</p> Name Type Description <code>tuple</code> <p>(index, item) for each element in reverse order.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def enumerate_backwards(self, object_list: List):\n    \"\"\"\n    Iterates backwards over a list, yielding index and item.\n\n    Args:\n        object_list (List): The list to iterate over.\n\n    Yields:\n        tuple: (index, item) for each element in reverse order.\n    \"\"\"\n    index = len(object_list)\n    for item in reversed(object_list):\n        index -= 1\n        yield index, item\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.init_collision_list","title":"<code>init_collision_list(room_object)</code>","text":"<p>Initializes the collision list for a given object.</p> <p>Parameters:</p> Name Type Description Default <code>room_object</code> <code>RoomObject</code> <p>The object to initialize collisions for.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def init_collision_list(self, room_object: RoomObject):\n    \"\"\"\n    Initializes the collision list for a given object.\n\n    Args:\n        room_object (RoomObject): The object to initialize collisions for.\n    \"\"\"\n    # - Initialise collision list for object - #\n    for obj_name in room_object.collision_object_types:\n        for obj_instance in self.objects:\n            if type(obj_instance).__name__ == obj_name and obj_instance is not room_object:\n                room_object.collision_objects.append(obj_instance)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.load_image","title":"<code>load_image(file_name)</code>","text":"<p>Returns the full path to an image file in the Images directory.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Filename of the image.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Full path to the image file.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def load_image(self, file_name: str) -&gt; str:\n    \"\"\"\n    Returns the full path to an image file in the Images directory.\n\n    Args:\n        file_name (str): Filename of the image.\n\n    Returns:\n        str: Full path to the image file.\n    \"\"\"\n    return os.path.join('Images', file_name)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.load_sound","title":"<code>load_sound(sound_file)</code>","text":"<p>Loads a sound file from the Sounds directory.</p> <p>Parameters:</p> Name Type Description Default <code>sound_file</code> <code>str</code> <p>Filename of the sound to load.</p> required <p>Returns:</p> Name Type Description <code>Sound</code> <code>Sound</code> <p>The loaded pygame Sound object.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def load_sound(self, sound_file: str) -&gt; Sound:\n    \"\"\"\n    Loads a sound file from the Sounds directory.\n\n    Args:\n        sound_file (str): Filename of the sound to load.\n\n    Returns:\n        Sound: The loaded pygame Sound object.\n    \"\"\"\n    fq_filename = os.path.join('Sounds', sound_file)\n    return pygame.mixer.Sound(fq_filename)\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.process_user_events","title":"<code>process_user_events()</code>","text":"<p>Processes and triggers any timed user events.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def process_user_events(self):\n    \"\"\"\n    Processes and triggers any timed user events.\n    \"\"\"\n    for index, user_event in self.enumerate_backwards(self.user_events):\n        user_event[0] -= 1\n        if user_event[0] &lt;= 0:\n            event = user_event[1]\n            self.user_events.pop(index)\n            event()\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.run","title":"<code>run()</code>","text":"<p>Runs the main game loop for the level.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the level is quitting, False otherwise.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def run(self) -&gt; bool:\n    \"\"\"\n    Runs the main game loop for the level.\n\n    Returns:\n        bool: True if the level is quitting, False otherwise.\n    \"\"\"\n    self.running = True\n    for obj in self.objects:\n        self.init_collision_list(obj)\n\n    while self.running:\n        self._clock.tick(Globals.FRAMES_PER_SECOND)\n\n        for obj in self.objects:\n            obj.prev_x = obj.x\n            obj.prev_y = obj.y\n\n        # - Process user events - #\n        self.process_user_events()\n\n        # Call Pre step on all objects\n        for item in self.objects:\n            item.prestep()\n\n        events = pygame.event.get()\n        for event in events:\n            if event.type == pygame.QUIT:\n                self.running = False\n                self.quitting = True\n                Globals.exiting = True\n                pass\n            # - Check for mouse click and pass to objects registered for mouse events - #\n            if event.type == pygame.MOUSEBUTTONUP:\n                mouse_pos = pygame.mouse.get_pos()\n                for obj in self.mouse_objects:\n                    if obj.rect.collidepoint(mouse_pos):\n                        obj.clicked(event.button)\n\n        # -  Check for joystick events and pass  - #\n        # - to objects registered for key events - #\n        signals = False\n        if self.has_buttons_1:\n            for i in range(self.joysticks[0].get_numbuttons()):\n                self.p1_btns[i] = self.joysticks[0].get_button(i)\n                if self.p1_btns[i] == 1:\n                    signals = True\n        if self.has_hat_1:\n            for i in range(self.joysticks[0].get_numaxes()):\n                self.p1_btns[-(i+1)] = self.joysticks[0].get_axis(i)\n                if self.p1_btns[-(i+1)] &gt; 0 or self.p1_btns[-(i+1)] &lt; 0:\n                    signals = True\n        if self.has_buttons_2:\n            for i in range(self.joysticks[1].get_numbuttons()):\n                self.p2_btns[i] = self.joysticks[1].get_button(i)\n                if self.p2_btns[i] == 1:\n                    signals = True\n        if self.has_hat_2:\n            for i in range(self.joysticks[1].get_numaxes()):\n                self.p1_btns[-i] = self.joysticks[1].get_axis(i)\n                if self.p2_btns[-i] &gt; 0 or self.p2_btns[-i] &lt; 0:\n                    signals = True\n\n        if signals:\n            for obj in self.keyboard_objects:\n                obj.joy_pad_signal(self.p1_btns, self.p2_btns)\n\n        # - Check for a keyboard event and pass - #\n        # - to objects registered for key events - #\n        keys = pygame.key.get_pressed()\n        if len(keys):\n            for obj in self.keyboard_objects:\n                obj.key_pressed(keys)\n\n        # - Check for a mouse event and pass - #\n        # - to objects registered for mouse events - #\n        (mouse_x, mouse_y) = pygame.mouse.get_pos()\n        (button_left, button_middle, button_right) = pygame.mouse.get_pressed()\n        for obj in self.mouse_objects:\n                obj.mouse_event(mouse_x, mouse_y, button_left, button_middle, button_right)\n\n        # - Handle all other events - #\n        self.catch_events(events)\n\n        # - Clear the screen - #\n        self.screen.fill(self.background_color)\n        # - Add Background if set - #\n        if self.background_set:\n            # - Scrolling if set - #\n            if self.background_scrolling:\n                self.background_y += self.background_scroll_speed\n                if self.background_y &gt;= Globals.SCREEN_HEIGHT:\n                    self.background_y = 0\n                self.screen.blit(self.background_image, (0, self.background_y))\n                self.screen.blit(self.background_image, (0, self.background_y - Globals.SCREEN_HEIGHT))\n            else:\n                self.screen.blit(self.background_image, (0, 0))\n        # Call Update on all objects\n        for item in self.objects:\n            item.update()\n            item.step()\n\n        # Check collisions\n        for item in self.objects:\n            item.check_collisions()\n\n        for item in self.objects:\n            self.screen.blit(item.image, (item.x, item.y))\n\n        pygame.display.update()\n\n    return self.quitting\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.set_background_image","title":"<code>set_background_image(image_file)</code>","text":"<p>Sets the background image for the level.</p> <p>Parameters:</p> Name Type Description Default <code>image_file</code> <code>str</code> <p>Filename of the background image.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def set_background_image(self, image_file: str):\n    \"\"\"\n    Sets the background image for the level.\n\n    Args:\n        image_file (str): Filename of the background image.\n    \"\"\"\n    self.background_set = True\n    self.background_image = pygame.image.load(os.path.join('Images', image_file)).convert_alpha()\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.set_background_scroll","title":"<code>set_background_scroll(speed)</code>","text":"<p>Enables background scrolling at the specified speed.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>int</code> <p>The scroll speed in pixels per frame.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def set_background_scroll(self, speed: int):\n    \"\"\"\n    Enables background scrolling at the specified speed.\n\n    Args:\n        speed (int): The scroll speed in pixels per frame.\n    \"\"\"\n    self.background_scrolling = True\n    self.background_scroll_speed = speed\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.set_timer","title":"<code>set_timer(ticks, function_call)</code>","text":"<p>Sets a timed event to call a function after a number of ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>Number of frames to wait before calling the function.</p> required <code>function_call</code> <code>Callable</code> <p>The function to call.</p> required Source code in <code>GameFrame/Level.py</code> <pre><code>def set_timer(self, ticks: int, function_call: Callable):\n    \"\"\"\n    Sets a timed event to call a function after a number of ticks.\n\n    Args:\n        ticks (int): Number of frames to wait before calling the function.\n        function_call (Callable): The function to call.\n    \"\"\"\n    self.user_events.append([ticks, function_call])\n</code></pre>"},{"location":"Level/#GameFrame.Level.Level.stop_sound","title":"<code>stop_sound()</code>","text":"<p>Stops all currently playing sounds.</p> Source code in <code>GameFrame/Level.py</code> <pre><code>def stop_sound(self):\n    \"\"\"\n    Stops all currently playing sounds.\n    \"\"\"\n    pygame.mixer.stop()\n</code></pre>"},{"location":"RoomObject/","title":"RoomObject Module","text":""},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject","title":"<code>RoomObject</code>","text":"<p>Base class for all objects that can exist in a game level (Room).</p> <p>Provides core functionality for position, movement, image handling, collision detection, event handling, and interaction with the game environment.</p> <p>Attributes:</p> Name Type Description <code>room</code> <code>Level</code> <p>The level or room this object belongs to.</p> <code>depth</code> <code>int</code> <p>Drawing order depth.</p> <code>x</code> <code>int</code> <p>X-coordinate of the object.</p> <code>y</code> <code>int</code> <p>Y-coordinate of the object.</p> <code>rect</code> <code>Rect</code> <p>The rectangle representing the object's position and size.</p> <code>prev_x</code> <code>int</code> <p>Previous X-coordinate (for movement/collision).</p> <code>prev_y</code> <code>int</code> <p>Previous Y-coordinate (for movement/collision).</p> <code>width</code> <code>int</code> <p>Width of the object.</p> <code>height</code> <code>int</code> <p>Height of the object.</p> <code>image</code> <p>The current image surface of the object.</p> <code>image_orig</code> <p>The original image surface (for rotation).</p> <code>curr_rotation</code> <code>int</code> <p>Current rotation angle.</p> <code>x_speed</code> <code>float</code> <p>Current speed in the X direction.</p> <code>y_speed</code> <code>float</code> <p>Current speed in the Y direction.</p> <code>gravity</code> <code>float</code> <p>Gravity applied to the object.</p> <code>handle_key_events</code> <code>bool</code> <p>Whether the object handles key events.</p> <code>handle_mouse_events</code> <code>bool</code> <p>Whether the object handles mouse events.</p> <code>angle</code> <code>int</code> <p>Current angle for movement or rotation.</p> <code>collision_object_types</code> <code>set</code> <p>Set of object type names to check collisions against.</p> <code>collision_objects</code> <code>list</code> <p>List of objects to check for collisions.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>class RoomObject:\n    \"\"\"\n    Base class for all objects that can exist in a game level (Room).\n\n    Provides core functionality for position, movement, image handling, collision detection,\n    event handling, and interaction with the game environment.\n\n    Attributes:\n        room (Level): The level or room this object belongs to.\n        depth (int): Drawing order depth.\n        x (int): X-coordinate of the object.\n        y (int): Y-coordinate of the object.\n        rect (pygame.Rect): The rectangle representing the object's position and size.\n        prev_x (int): Previous X-coordinate (for movement/collision).\n        prev_y (int): Previous Y-coordinate (for movement/collision).\n        width (int): Width of the object.\n        height (int): Height of the object.\n        image: The current image surface of the object.\n        image_orig: The original image surface (for rotation).\n        curr_rotation (int): Current rotation angle.\n        x_speed (float): Current speed in the X direction.\n        y_speed (float): Current speed in the Y direction.\n        gravity (float): Gravity applied to the object.\n        handle_key_events (bool): Whether the object handles key events.\n        handle_mouse_events (bool): Whether the object handles mouse events.\n        angle (int): Current angle for movement or rotation.\n        collision_object_types (set): Set of object type names to check collisions against.\n        collision_objects (list): List of objects to check for collisions.\n    \"\"\"\n\n    def __init__(self, room: Level, x: int, y: int):\n        \"\"\"\n        Initializes a RoomObject with position and default properties.\n\n        Args:\n            room (Level): The level or room this object belongs to.\n            x (int): Initial X-coordinate.\n            y (int): Initial Y-coordinate.\n        \"\"\"\n        self.room = room\n        self.depth = 0\n        self.x = x\n        self.y = y\n        self.rect = 0\n        self.prev_x = x\n        self.prev_y = y\n        self.width = 0\n        self.height = 0\n        self.image = 0\n        self.image_orig = 0\n        self.curr_rotation = 0\n        self.x_speed = 0\n        self.y_speed = 0\n        self.gravity = 0\n        self.handle_key_events = False\n        self.handle_mouse_events = False\n        self.angle = 0\n\n        self.collision_object_types = set()\n        self.collision_objects = []\n\n    @staticmethod\n    def load_image(file_name: str) -&gt; str:\n        \"\"\"\n        Returns the full path to an image file in the Images directory.\n\n        Args:\n            file_name (str): Filename of the image.\n\n        Returns:\n            str: Full path to the image file.\n        \"\"\"\n        return os.path.join('Images', file_name)\n\n    def set_image(self, image: str, width: int, height: int):\n        \"\"\"\n        Loads and sets the object's image, scaling to the given width and height.\n\n        Args:\n            image (str): Path to the image file.\n            width (int): Width to scale the image to.\n            height (int): Height to scale the image to.\n        \"\"\"\n        self.image_orig = pygame.image.load(image).convert_alpha()\n        self.image_orig = pygame.transform.scale(self.image_orig, (width, height))\n        self.width = width\n        self.height = height\n        self.image = self.image_orig.copy()\n        self.rect = pygame.Rect(self.x, self.y, width, height)\n\n    def register_collision_object(self, collision_object: str):\n        \"\"\"\n        Registers a type of object for collision detection.\n\n        Args:\n            collision_object (str): The class name of the object type to check collisions with.\n        \"\"\"\n        self.collision_object_types.add(collision_object)\n\n    def update(self):\n        \"\"\"\n        Updates the object's position based on speed and gravity.\n        \"\"\"\n        self.y_speed = self.y_speed + self.gravity\n        self.x += self.x_speed\n        self.y += self.y_speed\n        self.rect.x = self.x\n        self.rect.y = self.y\n\n    def delete_object(self, obj: 'RoomObject'):\n        \"\"\"\n        Removes an object from the level.\n\n        Args:\n            obj (RoomObject): The object to remove.\n        \"\"\"\n        self.room.delete_object(obj)\n\n    def remove_object(self, obj: 'RoomObject'):\n        \"\"\"\n        Removes an object from this object's collision list.\n\n        Args:\n            obj (RoomObject): The object to remove from collision_objects.\n        \"\"\"\n        for index, list_obj in enumerate(self.collision_objects):\n            if list_obj is obj:\n                self.collision_objects.pop(index)\n\n    def prestep(self):\n        \"\"\"\n        Optional: Called before the main step/update logic.\n        Override in subclasses for custom behavior.\n        \"\"\"\n        pass\n\n    def step(self):\n        \"\"\"\n        Optional: Called for the main step/update logic.\n        Override in subclasses for custom behavior.\n        \"\"\"\n        pass\n\n    def check_collisions(self):\n        \"\"\"\n        Checks for collisions with registered collision objects and handles them.\n        \"\"\"\n        for item in self.collision_objects:\n            if self.rect.colliderect(item.rect):\n                item_type = type(item).__name__\n                self.handle_collision(item, item_type)\n\n    def collides_at(self, obj, x, y, collision_type):\n        \"\"\"\n        Checks if moving an object to (x, y) would cause a collision with a given type.\n\n        Args:\n            obj (RoomObject): The object to check.\n            x (int): X offset.\n            y (int): Y offset.\n            collision_type (str): The class name of the object type to check against.\n\n        Returns:\n            bool: True if a collision would occur, False otherwise.\n        \"\"\"\n        check_rect = obj.rect.move(x, y)\n        collision_found = False\n        for item in self.collision_objects:\n            if check_rect.colliderect(item.rect):\n                if type(item).__name__ == collision_type:\n                    collision_found = True\n                    break\n        return collision_found\n\n    def handle_collision(self, other, other_type):\n        \"\"\"\n        Handles a collision with another object.\n        Override in subclasses for custom collision behavior.\n\n        Args:\n            other (RoomObject): The other object collided with.\n            other_type (str): The class name of the other object.\n        \"\"\"\n        pass\n\n    def key_pressed(self, key):\n        \"\"\"\n        Handles key press events.\n        Override in subclasses for custom key handling.\n\n        Args:\n            key: The pygame key state array.\n        \"\"\"\n        pass\n\n    def joy_pad_signal(self, p1_buttons: List[int], p2_buttons: List[int]):\n        \"\"\"\n        Handles joystick/gamepad input.\n        Override in subclasses for custom joystick handling.\n\n        Args:\n            p1_buttons (List[int]): Player 1 button/axis states.\n            p2_buttons (List[int]): Player 2 button/axis states.\n        \"\"\"\n        pass\n\n    def clicked(self, button_number):\n        \"\"\"\n        Handles mouse click events.\n        Override in subclasses for custom click handling.\n\n        Args:\n            button_number (int): The mouse button number clicked.\n        \"\"\"\n        pass\n\n    def mouse_event(self, mouse_x, mouse_y, button_left, button_middle, button_right):\n        \"\"\"\n        Handles mouse movement and button events.\n        Override in subclasses for custom mouse handling.\n\n        Args:\n            mouse_x (int): Mouse X position.\n            mouse_y (int): Mouse Y position.\n            button_left (bool): Left mouse button state.\n            button_middle (bool): Middle mouse button state.\n            button_right (bool): Right mouse button state.\n        \"\"\"\n        pass\n\n    def bounce(self, other):\n        \"\"\"\n        Reverses speed and position if this object bounces off another object.\n\n        Args:\n            other (RoomObject): The object to bounce off.\n        \"\"\"\n\n        # self is to the side of other\n        if other.rect.top &lt; self.rect.centery &lt; other.rect.bottom:\n            self.x_speed *= -1\n            self.x = self.prev_x\n\n        # self is above or below other\n        if other.rect.left &lt; self.rect.centerx &lt; other.rect.right:\n            self.y_speed *= -1\n            self.y = self.prev_y\n\n    def blocked(self):\n        \"\"\"\n        Stops movement and resets position if the object is blocked.\n        \"\"\"\n\n        self.x = self.prev_x\n        self.y = self.prev_y\n        self.x_speed = 0\n        self.y_speed = 0\n\n    def set_timer(self, ticks: int, function_call: Callable):\n        \"\"\"\n        Sets a timed event to call a function after a number of ticks.\n\n        Args:\n            ticks (int): Number of frames to wait before calling the function.\n            function_call (Callable): The function to call.\n        \"\"\"\n        self.room.set_timer(ticks, function_call)\n\n    def set_direction(self, angle: int, speed: int):\n        \"\"\"\n        Sets the object's movement direction and speed based on an angle.\n\n        Args:\n            angle (int): The angle in degrees.\n            speed (int): The speed value.\n        \"\"\"\n        self.x_speed = speed * math.cos(math.radians(angle % 360))\n        self.y_speed = (speed * math.sin(math.radians(angle % 360))) * -1\n\n        \"\"\"if angle &lt; 0:\n            pass\n        elif angle == 0:\n            self.x_speed = speed\n            self.y_speed = 0\n        elif angle &lt; 90:\n            self.x_speed, self.y_speed = self._get_direction(angle, speed)\n        elif angle == 90:\n            self.x_speed = 0\n            self.y_speed = speed\n        elif angle &lt; 180:\n            self.x_speed, self.y_speed = self._get_direction(angle - 90, speed)\n            self.x_speed, self.y_speed = -self.y_speed, self.x_speed\n        elif angle == 180:\n            self.x_speed = -speed\n            self.y_speed = 0\n        elif angle &lt; 270:\n            self.x_speed, self.y_speed = self._get_direction(angle - 180, speed)\n            self.x_speed, self.y_speed = -self.x_speed, -self.y_speed\n        elif angle == 270:\n            self.x_speed = 0\n            self.y_speed = -speed\n        elif angle &lt; 360:\n            self.x_speed, self.y_speed = self._get_direction(angle - 270, speed)\n            self.x_speed, self.y_speed = self.y_speed, -self.x_speed\"\"\"\n\n    @staticmethod\n    def _get_direction(angle: int, speed: int):\n        \"\"\"\n        Calculates X and Y speed components for a given angle and speed.\n\n        Args:\n            angle (int): The angle in degrees.\n            speed (int): The speed value.\n\n        Returns:\n            tuple: (x_speed, y_speed) as integers.\n        \"\"\"\n        # Use Trigonometry to calculate x_speed and y_speed values\n        new_x_speed = math.cos(math.radians(angle)) * speed\n        new_y_speed = math.sin(math.radians(angle)) * speed\n\n        return round(new_x_speed), round(new_y_speed)\n\n    def get_direction_coordinates(self, angle: int, speed: int) -&gt; Tuple[int, int]:\n        \"\"\"\n        Returns the X and Y coordinates for a given angle and speed.\n\n        Args:\n            angle (int): The angle in degrees.\n            speed (int): The speed value.\n\n        Returns:\n            Tuple[int, int]: The X and Y coordinates.\n        \"\"\"\n        x, y = 0, 0\n        angle += 90\n        if angle &gt;= 360:\n            angle = angle - 360\n\n        if angle == 0:\n            x = speed\n            y = 0\n        elif angle &lt; 90:\n            x, y = self._get_direction(angle + 90, speed)\n            x, y = y, x\n        elif angle == 90:\n            x = 0\n            y = -speed\n        elif angle &lt; 180:\n            x, y = self._get_direction(angle, speed)\n            y *= -1\n        elif angle == 180:\n            x = -speed\n            y = 0\n        elif angle &lt; 270:\n            x, y = self._get_direction(angle - 90, speed)\n            y, x = -x, -y\n        elif angle == 270:\n            x = 0\n            y = speed\n        elif angle &lt; 360:\n            x, y = self._get_direction(angle - 180, speed)\n            y, x = y, -x\n\n        return x, y\n\n    def rotate(self, angle: int):\n        \"\"\"\n        Rotates the object's image by the given angle.\n\n        Args:\n            angle (int): The angle to rotate by (in degrees).\n        \"\"\"\n\n        \"\"\"if self.curr_rotation &gt; 360:\n            self.curr_rotation = self.curr_rotation - 360\n        elif self.curr_rotation &lt; 0:\n            self.curr_rotation = 350 - self.curr_rotation\"\"\"\n\n        self.curr_rotation = self.angle = (angle + self.curr_rotation) % 360\n\n        self.image = pygame.transform.rotate(self.image_orig, self.angle)\n\n        x, y = self.rect.center\n\n        self.rect = self.image.get_rect()\n\n        self.x = x - int((self.rect.width / 2))\n        self.y = y - int((self.rect.height / 2))\n\n        self.rect.x = self.x\n        self.rect.y = self.y\n\n    def rotate_to_coordinate(self, mouse_x: int, mouse_y: int):\n        \"\"\"\n        Rotates the object to face a coordinate (e.g., mouse position).\n\n        Args:\n            mouse_x (int): The X coordinate to face.\n            mouse_y (int): The Y coordinate to face.\n        \"\"\"\n        distance_x = self.x + (self.width / 2) - mouse_x\n        distance_y = self.y + (self.height / 2) - mouse_y\n\n        angle = math.degrees(math.atan2(distance_x, distance_y))\n\n        self.curr_rotation = 0\n        self.rotate(int(angle))\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.__init__","title":"<code>__init__(room, x, y)</code>","text":"<p>Initializes a RoomObject with position and default properties.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Level</code> <p>The level or room this object belongs to.</p> required <code>x</code> <code>int</code> <p>Initial X-coordinate.</p> required <code>y</code> <code>int</code> <p>Initial Y-coordinate.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def __init__(self, room: Level, x: int, y: int):\n    \"\"\"\n    Initializes a RoomObject with position and default properties.\n\n    Args:\n        room (Level): The level or room this object belongs to.\n        x (int): Initial X-coordinate.\n        y (int): Initial Y-coordinate.\n    \"\"\"\n    self.room = room\n    self.depth = 0\n    self.x = x\n    self.y = y\n    self.rect = 0\n    self.prev_x = x\n    self.prev_y = y\n    self.width = 0\n    self.height = 0\n    self.image = 0\n    self.image_orig = 0\n    self.curr_rotation = 0\n    self.x_speed = 0\n    self.y_speed = 0\n    self.gravity = 0\n    self.handle_key_events = False\n    self.handle_mouse_events = False\n    self.angle = 0\n\n    self.collision_object_types = set()\n    self.collision_objects = []\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.blocked","title":"<code>blocked()</code>","text":"<p>Stops movement and resets position if the object is blocked.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def blocked(self):\n    \"\"\"\n    Stops movement and resets position if the object is blocked.\n    \"\"\"\n\n    self.x = self.prev_x\n    self.y = self.prev_y\n    self.x_speed = 0\n    self.y_speed = 0\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.bounce","title":"<code>bounce(other)</code>","text":"<p>Reverses speed and position if this object bounces off another object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>RoomObject</code> <p>The object to bounce off.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def bounce(self, other):\n    \"\"\"\n    Reverses speed and position if this object bounces off another object.\n\n    Args:\n        other (RoomObject): The object to bounce off.\n    \"\"\"\n\n    # self is to the side of other\n    if other.rect.top &lt; self.rect.centery &lt; other.rect.bottom:\n        self.x_speed *= -1\n        self.x = self.prev_x\n\n    # self is above or below other\n    if other.rect.left &lt; self.rect.centerx &lt; other.rect.right:\n        self.y_speed *= -1\n        self.y = self.prev_y\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.check_collisions","title":"<code>check_collisions()</code>","text":"<p>Checks for collisions with registered collision objects and handles them.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def check_collisions(self):\n    \"\"\"\n    Checks for collisions with registered collision objects and handles them.\n    \"\"\"\n    for item in self.collision_objects:\n        if self.rect.colliderect(item.rect):\n            item_type = type(item).__name__\n            self.handle_collision(item, item_type)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.clicked","title":"<code>clicked(button_number)</code>","text":"<p>Handles mouse click events. Override in subclasses for custom click handling.</p> <p>Parameters:</p> Name Type Description Default <code>button_number</code> <code>int</code> <p>The mouse button number clicked.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def clicked(self, button_number):\n    \"\"\"\n    Handles mouse click events.\n    Override in subclasses for custom click handling.\n\n    Args:\n        button_number (int): The mouse button number clicked.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.collides_at","title":"<code>collides_at(obj, x, y, collision_type)</code>","text":"<p>Checks if moving an object to (x, y) would cause a collision with a given type.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>RoomObject</code> <p>The object to check.</p> required <code>x</code> <code>int</code> <p>X offset.</p> required <code>y</code> <code>int</code> <p>Y offset.</p> required <code>collision_type</code> <code>str</code> <p>The class name of the object type to check against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if a collision would occur, False otherwise.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def collides_at(self, obj, x, y, collision_type):\n    \"\"\"\n    Checks if moving an object to (x, y) would cause a collision with a given type.\n\n    Args:\n        obj (RoomObject): The object to check.\n        x (int): X offset.\n        y (int): Y offset.\n        collision_type (str): The class name of the object type to check against.\n\n    Returns:\n        bool: True if a collision would occur, False otherwise.\n    \"\"\"\n    check_rect = obj.rect.move(x, y)\n    collision_found = False\n    for item in self.collision_objects:\n        if check_rect.colliderect(item.rect):\n            if type(item).__name__ == collision_type:\n                collision_found = True\n                break\n    return collision_found\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.delete_object","title":"<code>delete_object(obj)</code>","text":"<p>Removes an object from the level.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>RoomObject</code> <p>The object to remove.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def delete_object(self, obj: 'RoomObject'):\n    \"\"\"\n    Removes an object from the level.\n\n    Args:\n        obj (RoomObject): The object to remove.\n    \"\"\"\n    self.room.delete_object(obj)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.get_direction_coordinates","title":"<code>get_direction_coordinates(angle, speed)</code>","text":"<p>Returns the X and Y coordinates for a given angle and speed.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int</code> <p>The angle in degrees.</p> required <code>speed</code> <code>int</code> <p>The speed value.</p> required <p>Returns:</p> Type Description <code>Tuple[int, int]</code> <p>Tuple[int, int]: The X and Y coordinates.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def get_direction_coordinates(self, angle: int, speed: int) -&gt; Tuple[int, int]:\n    \"\"\"\n    Returns the X and Y coordinates for a given angle and speed.\n\n    Args:\n        angle (int): The angle in degrees.\n        speed (int): The speed value.\n\n    Returns:\n        Tuple[int, int]: The X and Y coordinates.\n    \"\"\"\n    x, y = 0, 0\n    angle += 90\n    if angle &gt;= 360:\n        angle = angle - 360\n\n    if angle == 0:\n        x = speed\n        y = 0\n    elif angle &lt; 90:\n        x, y = self._get_direction(angle + 90, speed)\n        x, y = y, x\n    elif angle == 90:\n        x = 0\n        y = -speed\n    elif angle &lt; 180:\n        x, y = self._get_direction(angle, speed)\n        y *= -1\n    elif angle == 180:\n        x = -speed\n        y = 0\n    elif angle &lt; 270:\n        x, y = self._get_direction(angle - 90, speed)\n        y, x = -x, -y\n    elif angle == 270:\n        x = 0\n        y = speed\n    elif angle &lt; 360:\n        x, y = self._get_direction(angle - 180, speed)\n        y, x = y, -x\n\n    return x, y\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.handle_collision","title":"<code>handle_collision(other, other_type)</code>","text":"<p>Handles a collision with another object. Override in subclasses for custom collision behavior.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>RoomObject</code> <p>The other object collided with.</p> required <code>other_type</code> <code>str</code> <p>The class name of the other object.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def handle_collision(self, other, other_type):\n    \"\"\"\n    Handles a collision with another object.\n    Override in subclasses for custom collision behavior.\n\n    Args:\n        other (RoomObject): The other object collided with.\n        other_type (str): The class name of the other object.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.joy_pad_signal","title":"<code>joy_pad_signal(p1_buttons, p2_buttons)</code>","text":"<p>Handles joystick/gamepad input. Override in subclasses for custom joystick handling.</p> <p>Parameters:</p> Name Type Description Default <code>p1_buttons</code> <code>List[int]</code> <p>Player 1 button/axis states.</p> required <code>p2_buttons</code> <code>List[int]</code> <p>Player 2 button/axis states.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def joy_pad_signal(self, p1_buttons: List[int], p2_buttons: List[int]):\n    \"\"\"\n    Handles joystick/gamepad input.\n    Override in subclasses for custom joystick handling.\n\n    Args:\n        p1_buttons (List[int]): Player 1 button/axis states.\n        p2_buttons (List[int]): Player 2 button/axis states.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.key_pressed","title":"<code>key_pressed(key)</code>","text":"<p>Handles key press events. Override in subclasses for custom key handling.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>The pygame key state array.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def key_pressed(self, key):\n    \"\"\"\n    Handles key press events.\n    Override in subclasses for custom key handling.\n\n    Args:\n        key: The pygame key state array.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.load_image","title":"<code>load_image(file_name)</code>  <code>staticmethod</code>","text":"<p>Returns the full path to an image file in the Images directory.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Filename of the image.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Full path to the image file.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>@staticmethod\ndef load_image(file_name: str) -&gt; str:\n    \"\"\"\n    Returns the full path to an image file in the Images directory.\n\n    Args:\n        file_name (str): Filename of the image.\n\n    Returns:\n        str: Full path to the image file.\n    \"\"\"\n    return os.path.join('Images', file_name)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.mouse_event","title":"<code>mouse_event(mouse_x, mouse_y, button_left, button_middle, button_right)</code>","text":"<p>Handles mouse movement and button events. Override in subclasses for custom mouse handling.</p> <p>Parameters:</p> Name Type Description Default <code>mouse_x</code> <code>int</code> <p>Mouse X position.</p> required <code>mouse_y</code> <code>int</code> <p>Mouse Y position.</p> required <code>button_left</code> <code>bool</code> <p>Left mouse button state.</p> required <code>button_middle</code> <code>bool</code> <p>Middle mouse button state.</p> required <code>button_right</code> <code>bool</code> <p>Right mouse button state.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def mouse_event(self, mouse_x, mouse_y, button_left, button_middle, button_right):\n    \"\"\"\n    Handles mouse movement and button events.\n    Override in subclasses for custom mouse handling.\n\n    Args:\n        mouse_x (int): Mouse X position.\n        mouse_y (int): Mouse Y position.\n        button_left (bool): Left mouse button state.\n        button_middle (bool): Middle mouse button state.\n        button_right (bool): Right mouse button state.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.prestep","title":"<code>prestep()</code>","text":"<p>Optional: Called before the main step/update logic. Override in subclasses for custom behavior.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def prestep(self):\n    \"\"\"\n    Optional: Called before the main step/update logic.\n    Override in subclasses for custom behavior.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.register_collision_object","title":"<code>register_collision_object(collision_object)</code>","text":"<p>Registers a type of object for collision detection.</p> <p>Parameters:</p> Name Type Description Default <code>collision_object</code> <code>str</code> <p>The class name of the object type to check collisions with.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def register_collision_object(self, collision_object: str):\n    \"\"\"\n    Registers a type of object for collision detection.\n\n    Args:\n        collision_object (str): The class name of the object type to check collisions with.\n    \"\"\"\n    self.collision_object_types.add(collision_object)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.remove_object","title":"<code>remove_object(obj)</code>","text":"<p>Removes an object from this object's collision list.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>RoomObject</code> <p>The object to remove from collision_objects.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def remove_object(self, obj: 'RoomObject'):\n    \"\"\"\n    Removes an object from this object's collision list.\n\n    Args:\n        obj (RoomObject): The object to remove from collision_objects.\n    \"\"\"\n    for index, list_obj in enumerate(self.collision_objects):\n        if list_obj is obj:\n            self.collision_objects.pop(index)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotates the object's image by the given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int</code> <p>The angle to rotate by (in degrees).</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def rotate(self, angle: int):\n    \"\"\"\n    Rotates the object's image by the given angle.\n\n    Args:\n        angle (int): The angle to rotate by (in degrees).\n    \"\"\"\n\n    \"\"\"if self.curr_rotation &gt; 360:\n        self.curr_rotation = self.curr_rotation - 360\n    elif self.curr_rotation &lt; 0:\n        self.curr_rotation = 350 - self.curr_rotation\"\"\"\n\n    self.curr_rotation = self.angle = (angle + self.curr_rotation) % 360\n\n    self.image = pygame.transform.rotate(self.image_orig, self.angle)\n\n    x, y = self.rect.center\n\n    self.rect = self.image.get_rect()\n\n    self.x = x - int((self.rect.width / 2))\n    self.y = y - int((self.rect.height / 2))\n\n    self.rect.x = self.x\n    self.rect.y = self.y\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.rotate_to_coordinate","title":"<code>rotate_to_coordinate(mouse_x, mouse_y)</code>","text":"<p>Rotates the object to face a coordinate (e.g., mouse position).</p> <p>Parameters:</p> Name Type Description Default <code>mouse_x</code> <code>int</code> <p>The X coordinate to face.</p> required <code>mouse_y</code> <code>int</code> <p>The Y coordinate to face.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def rotate_to_coordinate(self, mouse_x: int, mouse_y: int):\n    \"\"\"\n    Rotates the object to face a coordinate (e.g., mouse position).\n\n    Args:\n        mouse_x (int): The X coordinate to face.\n        mouse_y (int): The Y coordinate to face.\n    \"\"\"\n    distance_x = self.x + (self.width / 2) - mouse_x\n    distance_y = self.y + (self.height / 2) - mouse_y\n\n    angle = math.degrees(math.atan2(distance_x, distance_y))\n\n    self.curr_rotation = 0\n    self.rotate(int(angle))\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.set_direction","title":"<code>set_direction(angle, speed)</code>","text":"<p>Sets the object's movement direction and speed based on an angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>int</code> <p>The angle in degrees.</p> required <code>speed</code> <code>int</code> <p>The speed value.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def set_direction(self, angle: int, speed: int):\n    \"\"\"\n    Sets the object's movement direction and speed based on an angle.\n\n    Args:\n        angle (int): The angle in degrees.\n        speed (int): The speed value.\n    \"\"\"\n    self.x_speed = speed * math.cos(math.radians(angle % 360))\n    self.y_speed = (speed * math.sin(math.radians(angle % 360))) * -1\n\n    \"\"\"if angle &lt; 0:\n        pass\n    elif angle == 0:\n        self.x_speed = speed\n        self.y_speed = 0\n    elif angle &lt; 90:\n        self.x_speed, self.y_speed = self._get_direction(angle, speed)\n    elif angle == 90:\n        self.x_speed = 0\n        self.y_speed = speed\n    elif angle &lt; 180:\n        self.x_speed, self.y_speed = self._get_direction(angle - 90, speed)\n        self.x_speed, self.y_speed = -self.y_speed, self.x_speed\n    elif angle == 180:\n        self.x_speed = -speed\n        self.y_speed = 0\n    elif angle &lt; 270:\n        self.x_speed, self.y_speed = self._get_direction(angle - 180, speed)\n        self.x_speed, self.y_speed = -self.x_speed, -self.y_speed\n    elif angle == 270:\n        self.x_speed = 0\n        self.y_speed = -speed\n    elif angle &lt; 360:\n        self.x_speed, self.y_speed = self._get_direction(angle - 270, speed)\n        self.x_speed, self.y_speed = self.y_speed, -self.x_speed\"\"\"\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.set_image","title":"<code>set_image(image, width, height)</code>","text":"<p>Loads and sets the object's image, scaling to the given width and height.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file.</p> required <code>width</code> <code>int</code> <p>Width to scale the image to.</p> required <code>height</code> <code>int</code> <p>Height to scale the image to.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def set_image(self, image: str, width: int, height: int):\n    \"\"\"\n    Loads and sets the object's image, scaling to the given width and height.\n\n    Args:\n        image (str): Path to the image file.\n        width (int): Width to scale the image to.\n        height (int): Height to scale the image to.\n    \"\"\"\n    self.image_orig = pygame.image.load(image).convert_alpha()\n    self.image_orig = pygame.transform.scale(self.image_orig, (width, height))\n    self.width = width\n    self.height = height\n    self.image = self.image_orig.copy()\n    self.rect = pygame.Rect(self.x, self.y, width, height)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.set_timer","title":"<code>set_timer(ticks, function_call)</code>","text":"<p>Sets a timed event to call a function after a number of ticks.</p> <p>Parameters:</p> Name Type Description Default <code>ticks</code> <code>int</code> <p>Number of frames to wait before calling the function.</p> required <code>function_call</code> <code>Callable</code> <p>The function to call.</p> required Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def set_timer(self, ticks: int, function_call: Callable):\n    \"\"\"\n    Sets a timed event to call a function after a number of ticks.\n\n    Args:\n        ticks (int): Number of frames to wait before calling the function.\n        function_call (Callable): The function to call.\n    \"\"\"\n    self.room.set_timer(ticks, function_call)\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.step","title":"<code>step()</code>","text":"<p>Optional: Called for the main step/update logic. Override in subclasses for custom behavior.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def step(self):\n    \"\"\"\n    Optional: Called for the main step/update logic.\n    Override in subclasses for custom behavior.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"RoomObject/#GameFrame.RoomObject.RoomObject.update","title":"<code>update()</code>","text":"<p>Updates the object's position based on speed and gravity.</p> Source code in <code>GameFrame/RoomObject.py</code> <pre><code>def update(self):\n    \"\"\"\n    Updates the object's position based on speed and gravity.\n    \"\"\"\n    self.y_speed = self.y_speed + self.gravity\n    self.x += self.x_speed\n    self.y += self.y_speed\n    self.rect.x = self.x\n    self.rect.y = self.y\n</code></pre>"},{"location":"TextObject/","title":"TextObject Module","text":""},{"location":"TextObject/#GameFrame.TextObject.TextObject","title":"<code>TextObject</code>","text":"<p>               Bases: <code>RoomObject</code></p> <p>A drawable text object for displaying text in a game level.</p> <p>Inherits from RoomObject and provides functionality for rendering and updating text with customizable font, size, color, and style.</p> <p>Attributes:</p> Name Type Description <code>rendered_text</code> <p>The rendered pygame Surface of the text.</p> <code>rect</code> <code>Rect</code> <p>The rectangle representing the text's position and size.</p> <code>built_font</code> <p>The pygame Font object used for rendering.</p> <code>text</code> <code>str</code> <p>The text string to display.</p> <code>size</code> <code>int</code> <p>Font size.</p> <code>font</code> <code>str</code> <p>Font name.</p> <code>colour</code> <code>tuple</code> <p>RGB color of the text.</p> <code>bold</code> <code>bool</code> <p>Whether the font is bold.</p> Source code in <code>GameFrame/TextObject.py</code> <pre><code>class TextObject(RoomObject):\n    \"\"\"\n    A drawable text object for displaying text in a game level.\n\n    Inherits from RoomObject and provides functionality for rendering and updating text\n    with customizable font, size, color, and style.\n\n    Attributes:\n        rendered_text: The rendered pygame Surface of the text.\n        rect (pygame.Rect): The rectangle representing the text's position and size.\n        built_font: The pygame Font object used for rendering.\n        text (str): The text string to display.\n        size (int): Font size.\n        font (str): Font name.\n        colour (tuple): RGB color of the text.\n        bold (bool): Whether the font is bold.\n    \"\"\"\n\n    def __init__(self, room: Level, x: int, y: int, text='Not Set', size=60,\n                 font='Comic Sans MS', colour=(0, 0, 0), bold=False):\n        \"\"\"\n        Initializes a TextObject with the given properties.\n\n        Args:\n            room (Level): The game level or room where the object is placed.\n            x (int): The x-coordinate of the object.\n            y (int): The y-coordinate of the object.\n            text (str, optional): The text to display. Defaults to 'Not Set'.\n            size (int, optional): Font size. Defaults to 60.\n            font (str, optional): Font name. Defaults to 'Comic Sans MS'.\n            colour (tuple, optional): RGB color of the text. Defaults to (0, 0, 0).\n            bold (bool, optional): Whether the font is bold. Defaults to False.\n        \"\"\"\n        RoomObject.__init__(self, room, x, y)\n\n        self.rendered_text = 0\n        self.rect = 0\n        self.built_font = 0\n        self.text = text\n        self.size = size\n        self.font = font\n        self.colour = colour\n        self.bold = bold\n        self.update_text()\n\n    def update_text(self):\n        \"\"\"\n        Updates the rendered text surface and its rectangle based on current properties.\n        \"\"\"\n        self.built_font = pygame.font.SysFont(self.font, self.size, self.bold)\n        self.rendered_text = self.built_font.render(self.text, False, self.colour)\n        self.image = self.rendered_text\n        self.width, self.height = self.built_font.size(self.text)\n        self.rect = pygame.Rect(self.x, self.y, self.width, self.height)\n</code></pre>"},{"location":"TextObject/#GameFrame.TextObject.TextObject.__init__","title":"<code>__init__(room, x, y, text='Not Set', size=60, font='Comic Sans MS', colour=(0, 0, 0), bold=False)</code>","text":"<p>Initializes a TextObject with the given properties.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Level</code> <p>The game level or room where the object is placed.</p> required <code>x</code> <code>int</code> <p>The x-coordinate of the object.</p> required <code>y</code> <code>int</code> <p>The y-coordinate of the object.</p> required <code>text</code> <code>str</code> <p>The text to display. Defaults to 'Not Set'.</p> <code>'Not Set'</code> <code>size</code> <code>int</code> <p>Font size. Defaults to 60.</p> <code>60</code> <code>font</code> <code>str</code> <p>Font name. Defaults to 'Comic Sans MS'.</p> <code>'Comic Sans MS'</code> <code>colour</code> <code>tuple</code> <p>RGB color of the text. Defaults to (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>bold</code> <code>bool</code> <p>Whether the font is bold. Defaults to False.</p> <code>False</code> Source code in <code>GameFrame/TextObject.py</code> <pre><code>def __init__(self, room: Level, x: int, y: int, text='Not Set', size=60,\n             font='Comic Sans MS', colour=(0, 0, 0), bold=False):\n    \"\"\"\n    Initializes a TextObject with the given properties.\n\n    Args:\n        room (Level): The game level or room where the object is placed.\n        x (int): The x-coordinate of the object.\n        y (int): The y-coordinate of the object.\n        text (str, optional): The text to display. Defaults to 'Not Set'.\n        size (int, optional): Font size. Defaults to 60.\n        font (str, optional): Font name. Defaults to 'Comic Sans MS'.\n        colour (tuple, optional): RGB color of the text. Defaults to (0, 0, 0).\n        bold (bool, optional): Whether the font is bold. Defaults to False.\n    \"\"\"\n    RoomObject.__init__(self, room, x, y)\n\n    self.rendered_text = 0\n    self.rect = 0\n    self.built_font = 0\n    self.text = text\n    self.size = size\n    self.font = font\n    self.colour = colour\n    self.bold = bold\n    self.update_text()\n</code></pre>"},{"location":"TextObject/#GameFrame.TextObject.TextObject.update_text","title":"<code>update_text()</code>","text":"<p>Updates the rendered text surface and its rectangle based on current properties.</p> Source code in <code>GameFrame/TextObject.py</code> <pre><code>def update_text(self):\n    \"\"\"\n    Updates the rendered text surface and its rectangle based on current properties.\n    \"\"\"\n    self.built_font = pygame.font.SysFont(self.font, self.size, self.bold)\n    self.rendered_text = self.built_font.render(self.text, False, self.colour)\n    self.image = self.rendered_text\n    self.width, self.height = self.built_font.size(self.text)\n    self.rect = pygame.Rect(self.x, self.y, self.width, self.height)\n</code></pre>"}]}